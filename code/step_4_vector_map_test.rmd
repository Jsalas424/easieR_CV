---
title: "NN-Coregistration"
author: "Jonathan Salas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    df_print: kable
    fig_width: 7
    fig_height: 6
---

# Start with a clean slate

## Remove all objects

```{r echo = F, include=FALSE}
rm(list = ls(all.names = TRUE)) # Remove all starting code
```

## Detach Packages

```{r include=FALSE}
try(invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE)), silent = T) # Detach Packages
```


```{r setup, include=FALSE}
library(eiEAM)
library(gtsummary)
library(lme4)
library(lmerTest)
library(emmeans)
library(knitr)
library(RColorBrewer)
library(scales)
library(rgl)
library(plotly)
library(dplyr)
opts_knit$set(root.dir = "~/R_Projects/RBF_CV2/")
```

# What subject, timepoint, and pacing_dir are we working with?

```{r}
id <- "sbrt_16" # all lowercase, study_id format e.g., "sbrt_03"
timepoint <- "t1" # "t1" vs "t2" t1 = baseline; t2 = terminal
pacing_dir <- "apaced" # "rvpaced" vs "apaced"
diagnostic.plots <- T
```

# Import Data 

```{r echo=F}
# This is the raw data - we need this for the scar, lat coordinates, etc.
load(paste0("data/unaltered_data/",id,"_",timepoint,"_raw.RData"))
# We don't need the original mesh, we import the remeshed product
rm(carto_connex)
data_1 <- raw.data.1

# This is the remeshed data - this brings in remeshed_vertices_roi without their CVs
load(paste0("data/ready_to_analyze/",id,"/","remeshed_",.GlobalEnv$pacing_dir,"_",.GlobalEnv$timepoint,".RData"))

# This has the remeshed vertices with the RBF solution for their CVs
remesh_vertices_roi <- readRDS(paste0("data/working_data/","remeshed_cv_step_3_",.GlobalEnv$timepoint,".rds"))

# This is the triangulated result
tri_cv_raw <- readRDS(paste0("data/working_data","/","tri_cv_step_3_",.GlobalEnv$timepoint,".rds"))
tri_cv <- tri_cv_raw
```

# Data Validation - Make sure we loaded in the correct data from the working_data directory

```{r echo = F}
if(
  all(sapply(list(unique(remesh_vertices_roi$id)), 
             FUN = identical, 
             unique(tri_cv_raw$id)))
){
  print(paste0("Currently working with ", unique(remesh_vertices_roi$id)))
  id <- unique(remesh_vertices_roi$id)
} else{
  stop(
    paste0("ID's Don't Match")
  )
}
```

# Make working data

```{r echo=F}
remesh_vertices_roi <- remesh_vertices_roi |> filter(pacing_dir == .GlobalEnv$pacing_dir) |> mutate(lat = round(lat_annot - 2000,1)) |> select(-lat_annot)
tri_cv <- tri_cv |> filter(pacing_dir == .GlobalEnv$pacing_dir)
```

# Nearest Neighbor Scar Coregistration:

```{r echo = F}
neighbors_radius <- 1
n_neighbors <- 1

surf_data_train <-
  remesh_vertices_roi |> select(surf_x:surf_z)

surf_data_testing <-
  data_1 |> filter(group == "mri_scar" &
                     pacing_dir == .GlobalEnv$pacing_dir) |> select(x:z)

# Training data is what you want to project on to - CARTO Mesh
# Testing data is what the data you want to project - MRI Scar
if (nrow(surf_data_testing) != 0) {
  frnn_surf_data <- fr_nearest_neighbors(
    training_data = surf_data_train,
    testing_data = surf_data_testing,
    neighbors_radius = .GlobalEnv$neighbors_radius
  )
  
  nnn_surf_data <-
    n_nearest_neighbors(
      training_data = surf_data_train,
      testing_data = surf_data_testing,
      n_neighbors = .GlobalEnv$n_neighbors
    )
  
  # The distinct surf_x:surf_z coordinates are the carto mesh coordinates within x mm AND n-nearest neighbor to the scar. Thus, the distinct surf_x:surf_z coordinates on the endocardical surface that match the surf_x:surf_z coordinates of our points, are scar.
u_surf_coord <-
  distinct(rbind(frnn_surf_data,
                 nnn_surf_data),
           surf_x,
           surf_y,
           surf_z)
} else{
  print("No scar here!")
}
```

```{r echo = F}
if(nrow(surf_data_testing) != 0) {
  
  # If there are scar coordinates, label the surface vertices based on if they were or weren't in the u_surf_coord result
  remesh_vertices_roi <- bind_rows(
    anti_join(x = surf_data_train, y = u_surf_coord) |>
      mutate(region = "mri_healthy"),
    semi_join(x = surf_data_train, y  = u_surf_coord) |>
      mutate(region = "mri_scar")) |>
    left_join(x = remesh_vertices_roi)
  
  # Add the surf_dist
  remesh_vertices_roi <- left_join(
    y = nnn_surf_data |>
      group_by(surf_x, surf_y, surf_z) |>
      summarise(scar_dist = round(mean(surf_dist), 3)),
    x = remesh_vertices_roi
  ) |>
    arrange(idx)
  
  # Label Triangles Based on Number of Vertices Coregistered to Scar
  ## Instantiate temp variable
  temp <- vector(length = nrow(tri_cv))
  
  for (i in seq_along(1:nrow(tri_cv))) {
    region1 <- remesh_vertices_roi[tri_cv[[i, "v1"]], "region"]
    region2 <- remesh_vertices_roi[tri_cv[[i, "v2"]], "region"]
    region3 <- remesh_vertices_roi[tri_cv[[i, "v3"]], "region"]
    
    temp[i] <- Mode(c(region1, region2, region3))
    
  }
  
  tri_cv <- tri_cv |>
  cbind(region = temp,
        region_facecolor = if_else(temp == "mri_healthy", "purple", "red"))
  
} else{
  
    # If there aren't scar coordinates, label the surface vertices healthy
  temp <- surf_data_train |>
    mutate(region = "mri_healthy")
  print("No scar here!")
  
  # Combine Results with Original DF
  remesh_vertices_roi <- left_join(y = temp,
                                   x = remesh_vertices_roi |> filter(pacing_dir == .GlobalEnv$pacing_dir)) |>
    arrange(idx)
  
  tri_cv <- tri_cv |>
  mutate(region = "mri_healthy",
        region_facecolor = "purple")
}
```

```{r echo=F}
# Create mesh3d object with cleaning instead of cgalMesh
carto_mesh <- tmesh3d(
  vertices = t(as.matrix(remesh_vertices_roi[, 1:3])),
  indices = t(as.matrix(remesh_faces_roi[, 1:3])),
  homogeneous = FALSE
)

# Generate wireframe coordinates using Rvcg-compatible function
carto_wireframe <- create_wireframe_mesh(carto_mesh)
```

# Nearest Neighbor LAT Coregistration:

```{r echo = F}
n_neighbors <- 1

surf_data_testing <-
  remesh_vertices_roi |> select(surf_x:surf_z)

surf_data_train <-
  data_1 |> filter(group == "lat_coord" &
                     pacing_dir == .GlobalEnv$pacing_dir) |>
  select(x:z)

# Training data is what you want to project on to - LAT Coordinates 
# Testing data is what the data you want to project - Remesh 
if (nrow(surf_data_testing) != 0) {
  nnn_surf_data <-
    n_nearest_neighbors(
      training_data = surf_data_train,
      testing_data = surf_data_testing,
      n_neighbors = .GlobalEnv$n_neighbors
    )
} else{
  print("No LAT Coordinates here!")
}
```

```{r echo = F}
remesh_vertices_roi <-  left_join(
  y = nnn_surf_data |>
    select(-c(surf_x:surf_z)) |>
    rename(
      surf_x = x,
      surf_y = y,
      surf_z = z,
      lat_surf_dist = surf_dist
    ),
  x = remesh_vertices_roi
)
```

## Get Average CV <-> LAT Distance per Triangle

```{r echo = F}
res <- vector(length = nrow(tri_cv))
```

```{r echo = F}
for(i in seq_along(1:nrow(tri_cv))){
  
  vert1 <- remesh_vertices_roi[tri_cv[[i,"v1"]],"lat_surf_dist"]
  vert2 <- remesh_vertices_roi[tri_cv[[i,"v2"]],"lat_surf_dist"]
  vert3 <- remesh_vertices_roi[tri_cv[[i,"v3"]],"lat_surf_dist"]
  
  res[i] <- mean(vert1, vert2, vert3)
  
}
```

```{r echo = F}
tri_cv <- tri_cv |>
  cbind(tri_lat_dist = as.numeric(res)) |>
  mutate(tri_lat_dist = round(tri_lat_dist, 3))
```

# Plot Results

```{r}
plot_ly() |> 
  add_trace(
    name = "CARTO Wireframe",
    data = carto_wireframe,
    x = ~ x,
    y = ~ y,
    z = ~ z,
    type = "scatter3d",
    mode = "lines",
    line = list(color = "black", width = 3),
    showlegend = TRUE,
    hoverinfo = "none"
  ) |> 
    add_trace(
      name = "Averaged CV", type = "mesh3d", data = tri_cv,
      x = remesh_vertices_roi$surf_x, y = remesh_vertices_roi$surf_y, z = remesh_vertices_roi$surf_z,
      i = ~v1-1, j = ~v2-1, k = ~v3-1,
      flatshading = TRUE, showlegend = TRUE,
      facecolor = ~cv_facecolor
    ) |>
    add_trace(
      name = "RBF CV", type = "scatter3d", mode = "markers",
      data = remesh_vertices_roi,
      x = ~surf_x, y = ~surf_y, z = ~surf_z,
      showlegend = TRUE,
      marker = list(
#        color = ~cv_plot,         # capped CV for plotting
        colorscale = "YlOrRd",
        cmin = 0.1,    # lower limit from argument
        cmax = 0.4,
        colorbar = list(
          x = +0.5,
          y = -0.05,
          title = "CV (m/s)",
          orientation = "h"
        )
      )
    ) |>
    add_trace(
      name = "RBF LATs", type = "scatter3d", mode = "markers",
      data = remesh_vertices_roi,
      x = ~surf_x, y = ~surf_y, z = ~surf_z,
      showlegend = TRUE,
      hovertext = ~paste0("LAT: ", round(lat, 3)),
      marker = list(
        color = ~lat,
#        cmax = plot_max, cmin = plot_min,
        reversescale = TRUE,
        colorscale = "Jet",
        colorbar = list(x = -0.1, title = "Interpolated LAT (ms)", orientation = "V")
      )
    ) |>
      add_trace(
    type="cone",
    name = "CV Vectors",
    x = remesh_vertices_roi$surf_x, y = remesh_vertices_roi$surf_y, z = remesh_vertices_roi$surf_z,
#    u = t(wave_direction[,1]), v = t(wave_direction[,2]), w = t(wave_direction[,3]),
    u = t(wave_velocity[,1]), v = t(wave_velocity[,2]), w = t(wave_velocity[,3]),
    opacity=1,
    sizemode= 'scaled', # use "absolute" for wave_direction, use "scaled"
    sizeref= 10,
    showscale = FALSE,      # No colorbar needed
    showlegend = TRUE
  ) 
  
```

# Version and Package Details

```{r echo=F}
paste(version$version.string, version$nickname) 
paste0("RStudio Version ",rstudioapi::versionInfo()$version, " ", rstudioapi::versionInfo()$release_name) # RStudio Version
subset(data.frame(sessioninfo::package_info()), attached==TRUE, c(package, loadedversion)) # Loaded Packages
```

# When was this file last run to completion?

```{r}
date()
```